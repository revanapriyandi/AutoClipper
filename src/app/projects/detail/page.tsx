"use client";

import { useState, useEffect, useRef, Suspense, useCallback } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Loader2, Play, Download, Edit3, Send, Music, FolderOpen, ExternalLink, Clapperboard, Eye, Zap, Sparkles, Clock, Star, CheckCircle2 } from "lucide-react";
import { ScoredCandidate } from "@/lib/ai/scoring";
import { enrichCandidates } from "@/lib/ai/enrichment";
import { generateCandidates } from "@/lib/ai/segmentation";
import { scoreCandidate } from "@/lib/ai/scoring";
import { useRenderProgress } from "@/components/NotificationToast";

// ---- Types ----
interface ProjectRecord {
  id: string;
  title: string;
  sourcePath: string;
  durationMs: number;
  status: string;
}

// ---- Component ----
function ProjectDetailsContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const id = searchParams.get("id");
  const [project, setProject] = useState<ProjectRecord | null>(null);
  const [loading, setLoading] = useState(false);
  const [candidates, setCandidates] = useState<ScoredCandidate[]>([]);
  const [status, setStatus] = useState("Loading project data...");
  const [videoSrc, setVideoSrc] = useState<string | null>(null);
  const [outputPaths, setOutputPaths] = useState<Record<number, string>>({});
  const [jobIds, setJobIds] = useState<Record<number, string>>({});
  const [renderingClips, setRenderingClips] = useState<Set<number>>(new Set());
  const videoRef = useRef<HTMLVideoElement>(null);

  // F1: Render Progress
  const renderProgress = useRenderProgress();

  // F2: In-app clip preview
  const [previewModal, setPreviewModal] = useState<{ src: string; title: string } | null>(null);

  // Styling Editor State
  const [editingClipIndex, setEditingClipIndex] = useState<number | null>(null);
  const [editedChunks, setEditedChunks] = useState<{ startMs: number; endMs: number; text: string; words: { startMs: number; endMs: number; text: string }[] }[]>([]);
  const [fontName, setFontName] = useState("Impact");
  const [primaryColor, setPrimaryColor] = useState("&H0000FFFF");
  const [outlineColor, setOutlineColor] = useState("&H00000000");
  const [alignment, setAlignment] = useState("2");
  const [marginV, setMarginV] = useState("150");
  const [bgMusicPath, setBgMusicPath] = useState<string>("");
  const [themePresets, setThemePresets] = useState<{ id: string; name: string; fontFamily: string; primaryColor: string; outlineColor: string; alignment: string; marginV: string }[]>([]);

  // F6: Multi-variant captions
  const [captionVariants, setCaptionVariants] = useState<Record<number, string[]>>({});
  const [generatingCaptions, setGeneratingCaptions] = useState<Set<number>>(new Set());

  // Post Scheduling State
  const [scheduleModalOpen, setScheduleModalOpen] = useState(false);
  const [activeClipToPost, setActiveClipToPost] = useState<{ clip: ScoredCandidate; outputPath?: string } | null>(null);
  const [postPlatform, setPostPlatform] = useState("youtube");
  const [postDate, setPostDate] = useState(new Date().toISOString().split("T")[0]);
  const [postTime, setPostTime] = useState("12:00");
  const [postTitle, setPostTitle] = useState("");
  const [postDesc, setPostDesc] = useState("Auto-generated by AutoClipper #shorts #autoclipper");

  useEffect(() => {
    async function loadProject() {
      try {
        const api = window.electronAPI;
        if (!api) throw new Error("Electron API not found");
        if (!id) throw new Error("No Project ID provided in URL");
        const data = await api.dbGetProject(id) as { success: boolean; project?: ProjectRecord; error?: string };
        if (data.success && data.project) {
          setProject(data.project);
          setStatus("Ready. Click 'Auto-Cut Clips' to start the AI pipeline.");
          loadVideoPreview(data.project.sourcePath);
        } else {
          setStatus("Failed to load project: " + data.error);
        }
        if (api.dbGetThemePresets) {
          const presetsResp = await api.dbGetThemePresets();
          if (presetsResp.success && presetsResp.presets) setThemePresets(presetsResp.presets);
        }
      } catch (err: unknown) {
        setStatus("Error loading project: " + (err instanceof Error ? err.message : "Unknown error"));
      }
    }
    loadProject();
  }, [id]);

  const loadVideoPreview = async (sourcePath: string) => {
    const api = window.electronAPI;
    if (!api?.readVideoAsDataUrl) return;
    const res = await api.readVideoAsDataUrl(sourcePath);
    if (res.success && res.dataUrl) setVideoSrc(res.dataUrl);
  };

  const [brollKeywordMap, setBrollKeywordMap] = useState<Record<number, string[]>>({});

  // ============================
  // REAL AI Pipeline
  // ============================
  const handleGenerateClips = async () => {
    if (!project) return;
    setLoading(true);
    setCandidates([]);

    const api = window.electronAPI;
    const isElectron = !!api;

    try {
      let deepgramKey = "";
      if (isElectron && api.getKey) {
        const keyRes = await api.getKey("deepgram_key");
        deepgramKey = keyRes.value || "";
      }
      if (!deepgramKey) {
        setStatus("âš ï¸ Deepgram API Key belum dipasang. Silakan konfigurasikan via Settings.");
        setLoading(false);
        return;
      }

      setStatus("ðŸŽ™ï¸ Extracting audio & transcribing with Deepgram...");
      const transcribeRes = await api!.aiTranscribe(project.sourcePath, deepgramKey);
      if (!transcribeRes.success || !transcribeRes.results) throw new Error("Transcription failed: " + transcribeRes.error);

      const words = transcribeRes.results.channels[0].alternatives[0].words;
      const segments = words.map((w: { word: string; start: number; end: number }) => ({
        start: w.start, end: w.end, text: w.word,
        words: [{ word: w.word, start: w.start, end: w.end, confidence: 1, punctuated_word: w.word }]
      }));

      setStatus("âœ‚ï¸ Segmenting transcript into viral clip candidates...");
      const rawCandidates = generateCandidates(segments, { minDurationSec: 15, idealDurationSec: 30, maxDurationSec: 60 });
      if (rawCandidates.length === 0) { setStatus("No clip candidates found. Try a longer video."); setLoading(false); return; }

      setStatus(`ðŸ¤– Scoring ${Math.min(rawCandidates.length, 5)} candidates with LLM...`);
      const toScore = rawCandidates.slice(0, 5);
      const scored: ScoredCandidate[] = [];
      for (const candidate of toScore) {
        const result = await scoreCandidate(candidate);
        if (result) scored.push(result);
      }
      scored.sort((a, b) => b.totalScore - a.totalScore);

      setStatus("âœ¨ Injecting emojis & B-Roll keywords...");
      const { enriched, brollKeywordMap: newMap } = enrichCandidates(scored);
      setCandidates(enriched);
      setBrollKeywordMap(newMap);
      setStatus(`âœ… Done! ${enriched.length} clip(s) ready. Click 'Render 9:16' to export.`);
    } catch (err: unknown) {
      setStatus("âŒ Error: " + (err instanceof Error ? err.message : "Unknown error"));
    } finally {
      setLoading(false);
    }
  };

  // ============================
  // F6: Generate Multi-variant Captions
  // ============================
  const handleGenerateCaptions = async (clip: ScoredCandidate, index: number) => {
    setGeneratingCaptions(prev => new Set(prev).add(index));
    try {
      const api = window.electronAPI;
      if (!api?.captionGenerate) return;
      const res = await api.captionGenerate({ transcriptText: clip.transcriptText, count: 3 } as { transcriptText: string; count?: number; platforms?: string[] }) as { success: boolean; captions?: string[] };
      if (res.success && res.captions) {
        setCaptionVariants(prev => ({ ...prev, [index]: res.captions! }));
      } else {
        // Fallback: generate local variants
        const hook = clip.transcriptText.slice(0, 60);
        setCaptionVariants(prev => ({
          ...prev,
          [index]: [
            `ðŸ”¥ ${hook}... #shorts #viral`,
            `ðŸ’¡ Did you know? ${hook}... #learnontiktok`,
            `ðŸ‘€ ${hook}... #trending #fyp`,
          ]
        }));
      }
    } catch {
      const hook = clip.transcriptText.slice(0, 60);
      setCaptionVariants(prev => ({
        ...prev,
        [index]: [`ðŸ”¥ ${hook}...`, `ðŸ’¡ ${hook}...`, `ðŸ‘€ ${hook}...`]
      }));
    } finally {
      setGeneratingCaptions(prev => { const s = new Set(prev); s.delete(index); return s; });
    }
  };

  // ============================
  // F1: Render Clip with Progress Tracking
  // ============================
  const handleRender = useCallback(async (clip: ScoredCandidate, index: number) => {
    if (!project) return;
    const api = window.electronAPI;
    if (!api?.enqueueJob) { setStatus("Render requires Electron environment."); return; }

    const jobId = `render_clip${index + 1}_${Date.now()}`;
    setJobIds(prev => ({ ...prev, [index]: jobId }));
    setRenderingClips(prev => new Set(prev).add(index));
    setStatus(`âš™ï¸ Queuing render for Clip #${index + 1}...`);

    try {
      const res = await api.enqueueJob("RENDER", {
        jobId,
        sourcePath: project.sourcePath,
        startMs: clip.startMs,
        endMs: clip.endMs,
        segments: clip.chunks.map(c => ({
          start: c.startMs / 1000, end: c.endMs / 1000, text: c.text,
          words: c.words.map(w => ({ start: w.startMs / 1000, end: w.endMs / 1000, text: w.text }))
        })),
        isVerticalTarget: true,
        bgMusicPath: bgMusicPath || null,
        style: { font: fontName, primaryColor, outlineColor, alignment: parseInt(alignment), marginV: parseInt(marginV) }
      });

      if (!res.success) { setStatus("Failed to enqueue render: " + res.error); setRenderingClips(prev => { const s = new Set(prev); s.delete(index); return s; }); return; }

      const interval = setInterval(async () => {
        const jobRes = await api.getJob(jobId);
        if (jobRes?.success && jobRes.job) {
          const job = jobRes.job;
          if (job.status === "COMPLETED") {
            clearInterval(interval);
            const outputPath = `__CLIPS__/clip_${jobId}.mp4`;
            setOutputPaths(prev => ({ ...prev, [index]: outputPath }));
            setRenderingClips(prev => { const s = new Set(prev); s.delete(index); return s; });
            setStatus(`âœ… Clip #${index + 1} rendered! Click 'Preview' or 'Open File' to view.`);
          } else if (job.status === "FAILED") {
            clearInterval(interval);
            setRenderingClips(prev => { const s = new Set(prev); s.delete(index); return s; });
            setStatus(`âŒ Render failed: ${job.error}`);
          }
        }
      }, 2000);

    } catch (err: unknown) {
      setStatus("Error: " + (err instanceof Error ? err.message : "Unknown"));
      setRenderingClips(prev => { const s = new Set(prev); s.delete(index); return s; });
    }
  }, [project, bgMusicPath, fontName, primaryColor, outlineColor, alignment, marginV]);

  // F2: Load output video for in-app preview
  const handlePreviewClip = async (outputPath: string, index: number) => {
    const api = window.electronAPI;
    if (!api?.readVideoAsDataUrl) return;
    const res = await api.readVideoAsDataUrl(outputPath);
    if (res.success && res.dataUrl) {
      setPreviewModal({ src: res.dataUrl, title: `Clip #${index + 1} Preview` });
    }
  };

  const openScheduleModal = (clip: ScoredCandidate, index: number) => {
    setActiveClipToPost({ clip, outputPath: outputPaths[index] });
    setPostTitle("Amazing Short Video #viral");
    setScheduleModalOpen(true);
  };

  const handlePostSubmit = async () => {
    if (!activeClipToPost?.outputPath) {
      setStatus("Error: Clip must be rendered first before scheduling a post.");
      setScheduleModalOpen(false);
      return;
    }
    const api = window.electronAPI;
    if (!api?.enqueueJob) { setStatus("Post requires Electron."); return; }
    const combinedDateTime = new Date(`${postDate}T${postTime}`);
    const res = await api.enqueueJob("POST", {
      platform: postPlatform, videoPath: activeClipToPost.outputPath,
      title: postTitle, description: postDesc, tags: ["shorts", "viral"]
    }, combinedDateTime.toISOString());
    if (res.success) setStatus(`ðŸ“… Clip scheduled for ${postPlatform} at ${combinedDateTime.toLocaleString()}!`);
    else setStatus(`Failed scheduling: ${res.error}`);
    setScheduleModalOpen(false);
  };

  const openEditor = (clip: ScoredCandidate, index: number) => {
    setEditingClipIndex(index);
    setEditedChunks(clip.chunks.map(c => ({
      startMs: c.startMs, endMs: c.endMs, text: c.text,
      words: c.words.map(w => ({ startMs: w.startMs, endMs: w.endMs, text: w.text }))
    })));
  };

  const saveSubtitles = () => {
    if (editingClipIndex !== null) {
      setCandidates(prev => {
        const next = [...prev];
        next[editingClipIndex].chunks = editedChunks;
        return next;
      });
    }
    setEditingClipIndex(null);
  };

  const updateChunk = (idx: number, field: string, value: string | number) => {
    setEditedChunks(prev => { const next = [...prev]; next[idx] = { ...next[idx], [field]: value }; return next; });
  };

  const getScoreColor = (score: number) =>
    score >= 80 ? "text-green-400" : score >= 60 ? "text-yellow-400" : "text-red-400";

  // ============================
  // Render
  // ============================
  return (
    <div className="grid gap-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">{project ? project.title : "Project Studio"}</h2>
          <p className="text-muted-foreground text-sm">{project?.sourcePath}</p>
        </div>
        <Button onClick={handleGenerateClips} disabled={loading || !project} size="lg">
          {loading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Zap className="mr-2 h-4 w-4" />}
          Auto-Cut Clips
        </Button>
      </div>

      {status && (
        <div className="flex items-center gap-2 text-sm text-muted-foreground border p-3 rounded-lg bg-muted/30">
          {loading && <Loader2 className="h-3.5 w-3.5 animate-spin shrink-0" />}
          <span>{status}</span>
        </div>
      )}

      {/* Background Music */}
      <div className="flex items-center gap-3 p-3 border rounded-lg bg-muted/40">
        <Music className="h-4 w-4 text-muted-foreground flex-shrink-0" />
        <div className="flex-1">
          <label className="text-xs font-semibold">Background Music (.mp3)</label>
          <div className="flex gap-2 mt-1">
            <Input className="h-7 text-xs flex-1" placeholder="Optional â€” lofi.mp3" value={bgMusicPath} onChange={e => setBgMusicPath(e.target.value)} readOnly={!!(window.electronAPI)} />
            <Button size="sm" variant="outline" className="h-7 text-xs" onClick={async () => {
              const res = await window.electronAPI?.openFilePicker([{ name: "Audio Files", extensions: ["mp3", "wav", "ogg"] }]);
              if (res?.success && res.filePath) setBgMusicPath(res.filePath);
            }}>
              <FolderOpen className="h-3 w-3 mr-1" /> Browse
            </Button>
          </div>
        </div>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Video Player */}
        <Card>
          <CardHeader>
            <CardTitle>Video Preview</CardTitle>
            <CardDescription>Source â€” {project ? `${Math.round((project.durationMs || 0) / 1000)}s` : "loading..."}</CardDescription>
          </CardHeader>
          <CardContent className="flex justify-center bg-black rounded-b-lg min-h-[280px] items-center overflow-hidden p-0">
            {videoSrc ? (
              <video ref={videoRef} src={videoSrc} controls className="w-full max-h-[360px]" />
            ) : (
              <p className="text-muted-foreground text-sm p-6 text-center">
                {project ? "Loading video preview..." : "Select a project to preview."}
              </p>
            )}
          </CardContent>
        </Card>

        {/* Clip Cards */}
        <div className="flex flex-col gap-4">
          <h3 className="font-semibold text-lg">AI Generated Clips</h3>
          {candidates.length === 0 && !loading && (
            <Card className="border-dashed bg-muted/20 flex flex-col items-center justify-center py-10">
              <Play className="h-10 w-10 text-muted-foreground/30 mb-3" />
              <p className="text-sm text-muted-foreground">No clips generated yet. Click Auto-Cut to begin.</p>
            </Card>
          )}
          <div className="flex flex-col gap-3 max-h-[600px] overflow-y-auto pr-1">
            {candidates.map((c, i) => {
              const jobId = jobIds[i];
              const progress = jobId ? (renderProgress[jobId] ?? (renderingClips.has(i) ? 0 : null)) : null;
              const isDone = outputPaths[i] !== undefined;
              const isRendering = renderingClips.has(i);

              return (
                <Card key={i} className={`transition-all ${isDone ? "border-green-500/30 bg-green-950/10" : ""}`}>
                  <CardHeader className="pb-2 pt-4 px-4">
                    <div className="flex items-center justify-between">
                      <CardTitle className="text-sm font-semibold flex items-center gap-2">
                        {isDone && <CheckCircle2 className="h-4 w-4 text-green-400" />}
                        Clip #{i + 1}
                      </CardTitle>
                      <div className="flex items-center gap-2">
                        <span className="text-xs flex items-center gap-1 text-muted-foreground">
                          <Clock className="h-3 w-3" />
                          {((c.endMs - c.startMs) / 1000).toFixed(0)}s
                        </span>
                        <span className={`text-xs font-bold flex items-center gap-1 ${getScoreColor(c.totalScore)}`}>
                          <Star className="h-3 w-3" />
                          {c.totalScore}/100
                        </span>
                      </div>
                    </div>
                  </CardHeader>
                  <CardContent className="pb-4 px-4 space-y-3">
                    <p className="text-xs text-muted-foreground line-clamp-2 italic">&quot;{c.transcriptText}&quot;</p>

                    {/* B-Roll keywords */}
                    {brollKeywordMap[i]?.length > 0 && (
                      <div className="flex gap-1 flex-wrap">
                        {brollKeywordMap[i].map((kw, ki) => (
                          <Badge key={ki} variant="secondary" className="text-[10px] px-1.5 py-0">{kw}</Badge>
                        ))}
                      </div>
                    )}

                    {/* F6: Caption Variants */}
                    {captionVariants[i] && (
                      <div className="bg-muted/30 rounded-lg p-2 space-y-1">
                        <p className="text-[10px] font-semibold text-muted-foreground uppercase tracking-wider">Caption Options:</p>
                        {captionVariants[i].map((cap, ci) => (
                          <div key={ci} className="text-xs bg-background rounded px-2 py-1 border cursor-pointer hover:border-primary/50 transition-colors">
                            {cap}
                          </div>
                        ))}
                      </div>
                    )}

                    {/* F1: Render Progress Bar */}
                    {isRendering && progress !== null && (
                      <div className="space-y-1">
                        <div className="flex justify-between text-[10px] text-muted-foreground">
                          <span>Rendering...</span>
                          <span>{progress}%</span>
                        </div>
                        <Progress value={progress} className="h-1.5" />
                      </div>
                    )}

                    <div className="flex gap-1.5 flex-wrap pt-1">
                      <Button
                        variant="default" size="sm"
                        className="bg-purple-600 hover:bg-purple-700 text-white text-xs h-7"
                        onClick={() => {
                          if (!project) return;
                          const q = new URLSearchParams({
                            projectId: project.id, clipIndex: String(i),
                            startMs: String(c.startMs), endMs: String(c.endMs), source: project.sourcePath,
                          });
                          router.push(`/editor?${q.toString()}`);
                        }}
                      >
                        <Clapperboard className="mr-1 h-3 w-3" /> Editor
                      </Button>
                      <Button variant="outline" size="sm" className="text-xs h-7" onClick={() => openEditor(c, i)}>
                        <Edit3 className="mr-1 h-3 w-3" /> Subs
                      </Button>
                      <Button
                        variant="outline" size="sm" className="text-xs h-7"
                        onClick={() => handleGenerateCaptions(c, i)}
                        disabled={generatingCaptions.has(i)}
                      >
                        {generatingCaptions.has(i) ? <Loader2 className="mr-1 h-3 w-3 animate-spin" /> : <Sparkles className="mr-1 h-3 w-3" />}
                        Captions
                      </Button>
                      <Button
                        size="sm" className="text-xs h-7"
                        onClick={() => handleRender(c, i)}
                        disabled={isRendering}
                      >
                        {isRendering ? <Loader2 className="mr-1 h-3 w-3 animate-spin" /> : <Download className="mr-1 h-3 w-3" />}
                        Render
                      </Button>
                      {/* F2: In-app Preview */}
                      {isDone && (
                        <Button variant="secondary" size="sm" className="text-xs h-7" onClick={() => handlePreviewClip(outputPaths[i], i)}>
                          <Eye className="mr-1 h-3 w-3" /> Preview
                        </Button>
                      )}
                      {isDone && (
                        <Button variant="ghost" size="sm" className="text-xs h-7" onClick={() => window.electronAPI?.showItemInFolder(outputPaths[i])}>
                          <ExternalLink className="mr-1 h-3 w-3" /> File
                        </Button>
                      )}
                      <Button variant="ghost" size="sm" className="text-xs h-7" onClick={() => openScheduleModal(c, i)}>
                        <Send className="mr-1 h-3 w-3" /> Schedule
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              );
            })}
          </div>
        </div>
      </div>

      {/* F2: In-app Clip Preview Modal */}
      <Dialog open={!!previewModal} onOpenChange={(open) => !open && setPreviewModal(null)}>
        <DialogContent className="max-w-lg p-0 overflow-hidden">
          <DialogHeader className="p-4 pb-0">
            <DialogTitle>{previewModal?.title}</DialogTitle>
          </DialogHeader>
          <div className="bg-black flex justify-center">
            {previewModal && (
              <video src={previewModal.src} controls autoPlay className="max-h-[70vh] w-full" style={{ aspectRatio: "9/16", maxWidth: "calc(70vh * 9/16)" }} />
            )}
          </div>
        </DialogContent>
      </Dialog>

      {/* Subtitle Editor Dialog */}
      <Dialog open={editingClipIndex !== null} onOpenChange={(open) => !open && setEditingClipIndex(null)}>
        <DialogContent className="max-w-3xl">
          <DialogHeader>
            <DialogTitle>Edit Subtitles & Style</DialogTitle>
            <DialogDescription>Customize font, colors, positions, and adjust subtitle timings.</DialogDescription>
          </DialogHeader>
          {themePresets.length > 0 && (
            <div className="bg-muted/30 p-2 rounded border mb-3 flex items-center gap-3">
              <span className="text-sm font-medium">ðŸŽ¨ Apply Brand Kit:</span>
              <select className="text-sm border rounded p-1 bg-background" onChange={(e) => {
                const sel = themePresets.find(p => p.id === e.target.value);
                if (sel) { setFontName(sel.fontFamily); setPrimaryColor(sel.primaryColor); setOutlineColor(sel.outlineColor); setAlignment(sel.alignment); setMarginV(sel.marginV); }
              }}>
                <option value="">-- Select Preset --</option>
                {themePresets.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
              </select>
            </div>
          )}
          <div className="grid grid-cols-2 md:grid-cols-5 gap-3 py-2 border-b">
            {[
              { label: "Font", value: fontName, setter: setFontName, options: [["Arial","Arial"],["Impact","Impact"],["Roboto","Roboto"],["Comic Sans MS","Comic Sans"]] },
              { label: "Karaoke Color", value: primaryColor, setter: setPrimaryColor, options: [["&H0000FFFF","Yellow"],["&H0000FF00","Green"],["&H00FF0000","Blue"],["&H00FFFFFF","White"]] },
              { label: "Outline", value: outlineColor, setter: setOutlineColor, options: [["&H00000000","Black"],["&H000000FF","Red"],["&H00FFFFFF","White"]] },
              { label: "Alignment", value: alignment, setter: setAlignment, options: [["2","Bottom"],["8","Top"],["5","Middle"]] },
            ].map(({ label, value, setter, options }) => (
              <div key={label}>
                <label className="text-xs font-semibold">{label}</label>
                <select className="w-full text-sm border rounded p-1 mt-1 bg-background" value={value} onChange={e => setter(e.target.value)}>
                  {options.map(([val, name]) => <option key={val} value={val}>{name}</option>)}
                </select>
              </div>
            ))}
            <div>
              <label className="text-xs font-semibold">Margin Y</label>
              <Input type="number" className="h-8 mt-1" value={marginV} onChange={e => setMarginV(e.target.value)} />
            </div>
          </div>
          <div className="grid gap-2 py-4 max-h-[50vh] overflow-y-auto">
            {editedChunks.map((chunk, idx) => (
              <div key={idx} className="flex flex-col gap-1 text-sm border-b pb-2">
                <div className="flex items-center gap-2">
                  <span className="w-6 font-semibold text-muted-foreground">{idx + 1}.</span>
                  <div className="flex items-center gap-1">
                    <Input type="number" className="w-20 h-7 text-xs" value={chunk.startMs} onChange={e => updateChunk(idx, "startMs", parseInt(e.target.value) || 0)} />
                    <span className="text-muted-foreground text-xs">â€“</span>
                    <Input type="number" className="w-20 h-7 text-xs" value={chunk.endMs} onChange={e => updateChunk(idx, "endMs", parseInt(e.target.value) || 0)} />
                  </div>
                </div>
                <Input className="w-full h-8 ml-8 text-sm" value={chunk.text} onChange={e => updateChunk(idx, "text", e.target.value)} />
              </div>
            ))}
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setEditingClipIndex(null)}>Cancel</Button>
            <Button onClick={saveSubtitles}>Save Changes</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Schedule Post Dialog */}
      <Dialog open={scheduleModalOpen} onOpenChange={setScheduleModalOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Schedule Social Post</DialogTitle>
            <DialogDescription>Clip akan diunggah ke platform terpilih pada waktu yang ditentukan.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-3 py-2">
            <div>
              <label className="text-xs font-semibold">Platform</label>
              <select className="w-full h-9 border rounded px-2 mt-1 text-sm bg-background" value={postPlatform} onChange={e => setPostPlatform(e.target.value)}>
                <option value="youtube">YouTube Shorts</option>
                <option value="tiktok">TikTok</option>
                <option value="facebook">Facebook Reels</option>
              </select>
            </div>
            <div>
              <label className="text-xs font-semibold">Judul Video</label>
              <Input className="mt-1" value={postTitle} onChange={e => setPostTitle(e.target.value)} />
            </div>
            <div>
              <label className="text-xs font-semibold">Deskripsi</label>
              <Input className="mt-1" value={postDesc} onChange={e => setPostDesc(e.target.value)} />
            </div>
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="text-xs font-semibold">Tanggal</label>
                <Input className="mt-1" type="date" value={postDate} onChange={e => setPostDate(e.target.value)} />
              </div>
              <div>
                <label className="text-xs font-semibold">Waktu</label>
                <Input className="mt-1" type="time" value={postTime} onChange={e => setPostTime(e.target.value)} />
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setScheduleModalOpen(false)}>Batal</Button>
            <Button onClick={handlePostSubmit}>Schedule Now</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

export default function ProjectDetailsPage() {
  return (
    <Suspense fallback={<div className="p-10 flex justify-center"><Loader2 className="animate-spin text-muted-foreground mr-2 h-5 w-5" />Loading Project...</div>}>
      <ProjectDetailsContent />
    </Suspense>
  );
}
