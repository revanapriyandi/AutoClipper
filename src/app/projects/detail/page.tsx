"use client";

import { useState, useEffect, useRef, Suspense } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Loader2, Play, Download, Edit3, Send, Music, FolderOpen, ExternalLink, Clapperboard } from "lucide-react";
import { ScoredCandidate } from "@/lib/ai/scoring";
import { enrichCandidates } from "@/lib/ai/enrichment";
import { generateCandidates } from "@/lib/ai/segmentation";
import { scoreCandidate } from "@/lib/ai/scoring";

// Global window.electronAPI types are declared in src/types/electron.d.ts

// ---- Types ----
interface ProjectRecord {
  id: string;
  title: string;
  sourcePath: string;
  durationMs: number;
  status: string;
}

// ---- Component ----
function ProjectDetailsContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const id = searchParams.get("id");
  const [project, setProject] = useState<ProjectRecord | null>(null);
  const [loading, setLoading] = useState(false);
  const [candidates, setCandidates] = useState<ScoredCandidate[]>([]);
  const [status, setStatus] = useState("Loading project data...");
  const [videoSrc, setVideoSrc] = useState<string | null>(null);
  const [outputPaths, setOutputPaths] = useState<Record<number, string>>({});
  const videoRef = useRef<HTMLVideoElement>(null);

  // Styling Editor State
  const [editingClipIndex, setEditingClipIndex] = useState<number | null>(null);
  const [editedChunks, setEditedChunks] = useState<{ startMs: number; endMs: number; text: string; words: { startMs: number; endMs: number; text: string }[]; }[]>([]);
  const [fontName, setFontName] = useState("Impact");
  const [primaryColor, setPrimaryColor] = useState("&H0000FFFF");
  const [outlineColor, setOutlineColor] = useState("&H00000000");
  const [alignment, setAlignment] = useState("2");
  const [marginV, setMarginV] = useState("150");
  const [bgMusicPath, setBgMusicPath] = useState<string>("");
  const [themePresets, setThemePresets] = useState<{ id: string; name: string; fontFamily: string; primaryColor: string; outlineColor: string; alignment: string; marginV: string }[]>([]);

  // Post Scheduling State
  const [scheduleModalOpen, setScheduleModalOpen] = useState(false);
  const [activeClipToPost, setActiveClipToPost] = useState<{ clip: ScoredCandidate, outputPath?: string } | null>(null);
  const [postPlatform, setPostPlatform] = useState("youtube");
  const [postDate, setPostDate] = useState(new Date().toISOString().split('T')[0]);
  const [postTime, setPostTime] = useState("12:00");
  const [postTitle, setPostTitle] = useState("");
  const [postDesc, setPostDesc] = useState("Auto-generated by AutoClipper #shorts #autoclipper");

  useEffect(() => {
    async function loadProject() {
      try {
        const api = window.electronAPI;
        if (!api) throw new Error("Electron API not found");
        if (!id) throw new Error("No Project ID provided in URL");
        const data = await api.dbGetProject(id) as { success: boolean, project?: ProjectRecord, error?: string };
        if (data.success && data.project) {
          setProject(data.project);
          setStatus("Ready. Click 'Auto-Cut Clips' to start the AI pipeline.");
          // Load video preview
          loadVideoPreview(data.project.sourcePath);
        } else {
          setStatus("Failed to load project: " + data.error);
        }

        // Load Brand Kits Presets
        if (api.dbGetThemePresets) {
          const presetsResp = await api.dbGetThemePresets();
          if (presetsResp.success && presetsResp.presets) {
            setThemePresets(presetsResp.presets);
          }
        }
      } catch (err: unknown) {
        setStatus("Error loading project: " + (err instanceof Error ? err.message : "Unknown error"));
      }
    }
    loadProject();
  }, [id]);

  const loadVideoPreview = async (sourcePath: string) => {
    const api = window.electronAPI;
    if (!api?.readVideoAsDataUrl) return;
    const res = await api.readVideoAsDataUrl(sourcePath);
    if (res.success && res.dataUrl) setVideoSrc(res.dataUrl);
  };

  // ---- B-Roll ----
  const [brollKeywordMap, setBrollKeywordMap] = useState<Record<number, string[]>>({});


  // ============================
  // REAL AI Pipeline
  // ============================
  const handleGenerateClips = async () => {
    if (!project) return;
    setLoading(true);
    setCandidates([]);

    const api = window.electronAPI;
    const isElectron = !!api;

    try {
      // ---- Step 1: Get API key ----
      let deepgramKey = "";
      if (isElectron && api.getKey) {
        const keyRes = await api.getKey("deepgram_key");
        deepgramKey = keyRes.value || "";
      }
      if (!deepgramKey) {
        setStatus("âš ï¸ Deepgram API Key belum dipasang. Silakan konfigurasikan via menu Settings terlebih dahulu.");
        setLoading(false);
        return;
      }

      // ---- Step 2: Transcribe ----
      setStatus("ðŸŽ™ï¸ Extracting audio & transcribing with Deepgram...");
      const transcribeRes = await api!.aiTranscribe(project.sourcePath, deepgramKey);
      if (!transcribeRes.success || !transcribeRes.results) {
        throw new Error("Transcription failed: " + transcribeRes.error);
      }

      const words = transcribeRes.results.channels[0].alternatives[0].words;
      const segments = words.map((w: { word: string; start: number; end: number }) => ({
        start: w.start,
        end: w.end,
        text: w.word,
        words: [{ word: w.word, start: w.start, end: w.end, confidence: 1, punctuated_word: w.word }]
      }));

      // ---- Step 3: Segment ----
      setStatus("âœ‚ï¸ Segmenting transcript into viral clip candidates...");
      const rawCandidates = generateCandidates(segments, { minDurationSec: 15, idealDurationSec: 30, maxDurationSec: 60 });

      if (rawCandidates.length === 0) {
        setStatus("No clip candidates found. Try a longer video.");
        setLoading(false);
        return;
      }

      // ---- Step 4: Score top candidates (limited to 5 to save API calls) ----
      setStatus(`ðŸ¤– Scoring ${Math.min(rawCandidates.length, 5)} candidates with LLM...`);
      const toScore = rawCandidates.slice(0, 5);
      const scored: ScoredCandidate[] = [];

      for (const candidate of toScore) {
        const result = await scoreCandidate(candidate);
        if (result) scored.push(result);
      }

      scored.sort((a, b) => b.totalScore - a.totalScore);

      // ---- Step 5: Enrich ----
      setStatus("âœ¨ Injecting emojis & B-Roll keywords...");
      const { enriched, brollKeywordMap: newMap } = enrichCandidates(scored);
      setCandidates(enriched);
      setBrollKeywordMap(newMap);
      setStatus(`âœ… Done! ${enriched.length} clip(s) ready. Click 'Render 9:16' to export.`);

    } catch (err: unknown) {
      setStatus("âŒ Error: " + (err instanceof Error ? err.message : "Unknown error"));
    } finally {
      setLoading(false);
    }
  };



  // ============================
  // Render Clip
  // ============================
  const handleRender = async (clip: ScoredCandidate, index: number) => {
    if (!project) return;
    setStatus(`âš™ï¸ Starting render for Clip #${index + 1}...`);

    const api = window.electronAPI;
    if (!api?.enqueueJob) {
      setStatus("Render requires Electron environment.");
      return;
    }

    const jobId = `render_clip${index + 1}_${Date.now()}`;
    const outputPath = `__CLIPS__/clip_${jobId}.mp4`; // placeholder; actual path resolved by backend

    try {
      const res = await api.enqueueJob('RENDER', {
        jobId,
        sourcePath: project.sourcePath,
        startMs: clip.startMs,
        endMs: clip.endMs,
        segments: clip.chunks.map(c => ({
          start: c.startMs / 1000, end: c.endMs / 1000, text: c.text,
          words: c.words.map(w => ({ start: w.startMs / 1000, end: w.endMs / 1000, text: w.text }))
        })),
        isVerticalTarget: true,
        bgMusicPath: bgMusicPath || null,
        style: { font: fontName, primaryColor, outlineColor, alignment: parseInt(alignment), marginV: parseInt(marginV) }
      });

      if (!res.success) {
        setStatus("Failed to enqueue render: " + res.error);
        return;
      }

      setStatus(`â³ Render job ${jobId} queued. Processing...`);

      const interval = setInterval(async () => {
        const jobRes = await api.getJob(jobId);
        if (jobRes?.success && jobRes.job) {
          const job = jobRes.job;
          if (job.status === 'COMPLETED') {
            clearInterval(interval);
            setOutputPaths(prev => ({ ...prev, [index]: outputPath }));
            setStatus(`âœ… Clip #${index + 1} rendered! Click 'Open File' to view it.`);
          } else if (job.status === 'FAILED') {
            clearInterval(interval);
            setStatus(`âŒ Render failed: ${job.error}`);
          } else {
            setStatus(`â³ Render status: ${job.status}...`);
          }
        }
      }, 2000);

    } catch (err: unknown) {
      setStatus("Error: " + (err instanceof Error ? err.message : "Unknown"));
    }
  };

  const openScheduleModal = (clip: ScoredCandidate, index: number) => {
    setActiveClipToPost({ clip, outputPath: outputPaths[index] });
    setPostTitle("Amazing Short Video #viral"); // remove non-existent caption
    setScheduleModalOpen(true);
  };

  const handlePostSubmit = async () => {
    if (!activeClipToPost?.outputPath) {
      setStatus("Error: Clip must be rendered first before scheduling a post.");
      setScheduleModalOpen(false);
      return;
    }
    
    const api = window.electronAPI;
    if (!api?.enqueueJob) { setStatus("Post requires Electron."); return; }

    const combinedDateTime = new Date(`${postDate}T${postTime}`);

    const res = await api.enqueueJob('POST', {
      platform: postPlatform,
      videoPath: activeClipToPost.outputPath,
      title: postTitle,
      description: postDesc,
      tags: ["shorts", "viral"]
    }, combinedDateTime.toISOString());

    if (res.success) {
      setStatus(`ðŸ“… Clip scheduled for ${postPlatform} at ${combinedDateTime.toLocaleString()}!`);
    } else {
      setStatus(`Failed scheduling: ${res.error}`);
    }
    setScheduleModalOpen(false);
  };

  const openEditor = (clip: ScoredCandidate, index: number) => {
    setEditingClipIndex(index);
    setEditedChunks(clip.chunks.map(c => ({
      startMs: c.startMs, endMs: c.endMs, text: c.text,
      words: c.words.map(w => ({ startMs: w.startMs, endMs: w.endMs, text: w.text }))
    })));
  };

  const saveSubtitles = () => {
    if (editingClipIndex !== null) {
      setCandidates(prev => {
        const next = [...prev];
        next[editingClipIndex].chunks = editedChunks;
        return next;
      });
    }
    setEditingClipIndex(null);
  };

  const updateChunk = (idx: number, field: string, value: string | number) => {
    setEditedChunks(prev => {
      const next = [...prev];
      next[idx] = { ...next[idx], [field]: value };
      return next;
    });
  };

  // ============================
  // Render
  // ============================
  return (
    <div className="grid gap-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">{project ? project.title : "Project Studio"}</h2>
          <p className="text-muted-foreground text-sm">{project?.sourcePath}</p>
        </div>
        <Button onClick={handleGenerateClips} disabled={loading || !project}>
          {loading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Play className="mr-2 h-4 w-4" />}
          Auto-Cut Clips
        </Button>
      </div>

      {status && <p className="text-sm text-muted-foreground border p-2 rounded-md bg-muted/30">{status}</p>}

      {/* Background Music */}
      <div className="flex items-center gap-3 p-3 border rounded-lg bg-muted/40">
        <Music className="h-4 w-4 text-muted-foreground flex-shrink-0" />
        <div className="flex-1">
          <label className="text-xs font-semibold">Background Music (.mp3)</label>
          <div className="flex gap-2 mt-1">
            <Input className="h-7 text-xs flex-1" placeholder="C:\Music\lofi.mp3 (optional)" value={bgMusicPath} onChange={e => setBgMusicPath(e.target.value)} readOnly={!!(window.electronAPI)} />
            <Button size="sm" variant="outline" className="h-7 text-xs" onClick={async () => {
              const res = await window.electronAPI?.openFilePicker([{ name: 'Audio Files', extensions: ['mp3', 'wav', 'ogg'] }]);
              if (res?.success && res.filePath) setBgMusicPath(res.filePath);
            }}>
              <FolderOpen className="h-3 w-3 mr-1" /> Browse
            </Button>
          </div>
        </div>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Video Player */}
        <Card>
          <CardHeader>
            <CardTitle>Video Preview</CardTitle>
            <CardDescription>Original Source â€” {project ? `${Math.round((project.durationMs || 0) / 1000)}s` : "loading..."}</CardDescription>
          </CardHeader>
          <CardContent className="flex justify-center bg-black rounded-md min-h-[280px] items-center overflow-hidden p-0">
            {videoSrc ? (
              <video ref={videoRef} src={videoSrc} controls className="w-full max-h-[360px] rounded-md" />
            ) : (
              <p className="text-muted-foreground text-sm p-6 text-center">
                {project ? "Loading video preview..." : "Select a project to preview video."}
              </p>
            )}
          </CardContent>
        </Card>

        {/* Clip Cards */}
        <div className="flex flex-col gap-4">
          <h3 className="font-semibold text-lg">AI Generated Clips</h3>
          {candidates.length === 0 && !loading && (
            <p className="text-sm text-muted-foreground border p-4 rounded-md">No clips generated yet. Click Auto-Cut to begin.</p>
          )}
          {candidates.map((c, i) => (
            <Card key={i}>
              <CardHeader className="py-3">
                <CardTitle className="text-md flex justify-between">
                  <span>Clip #{i + 1}</span>
                  <span className="text-blue-500">Score: {c.totalScore}/100</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="pb-3 text-sm">
                <p className="mb-2 line-clamp-2 text-muted-foreground">&quot;{c.transcriptText}&quot;</p>
                {brollKeywordMap[i]?.length > 0 && (
                  <div className="flex gap-1 flex-wrap mb-2">
                    <span className="text-xs text-muted-foreground">B-Roll:</span>
                    {brollKeywordMap[i].map((kw, ki) => (
                      <span key={ki} className="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full">{kw}</span>
                    ))}
                  </div>
                )}
                <div className="flex gap-2 justify-between items-center mt-4">
                  <span className="text-xs text-muted-foreground">{(c.startMs / 1000).toFixed(1)}s â€“ {(c.endMs / 1000).toFixed(1)}s</span>
                  <div className="flex gap-2 flex-wrap justify-end">
                    <Button
                      variant="default"
                      size="sm"
                      className="bg-purple-600 hover:bg-purple-700 text-white"
                      onClick={() => {
                        if (!project) return;
                        const q = new URLSearchParams({
                          projectId: project.id,
                          clipIndex: String(i),
                          startMs:   String(c.startMs),
                          endMs:     String(c.endMs),
                          source:    project.sourcePath,
                        });
                        router.push(`/editor?${q.toString()}`);
                      }}
                    >
                      <Clapperboard className="mr-1 h-3 w-3" /> Video Editor
                    </Button>
                    <Button variant="outline" size="sm" onClick={() => openEditor(c, i)}>
                      <Edit3 className="mr-1 h-3 w-3" /> Edit Subs
                    </Button>
                    <Button size="sm" onClick={() => handleRender(c, i)}>
                      <Download className="mr-1 h-3 w-3" /> Render 9:16
                    </Button>
                    {outputPaths[i] && (
                      <Button variant="secondary" size="sm" onClick={() => window.electronAPI?.showItemInFolder(outputPaths[i])}>
                        <ExternalLink className="mr-1 h-3 w-3" /> Open File
                      </Button>
                    )}
                    <Button variant="ghost" size="sm" onClick={() => openScheduleModal(c, i)}>
                      <Send className="mr-1 h-3 w-3" /> Schedule Post
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </div>

      {/* Subtitle Editor Dialog */}
      <Dialog open={editingClipIndex !== null} onOpenChange={(open) => !open && setEditingClipIndex(null)}>
        <DialogContent className="max-w-3xl">
          <DialogHeader>
            <DialogTitle>Edit Subtitles & Style</DialogTitle>
            <DialogDescription>Customize font, colors, positions, and adjust subtitle timings.</DialogDescription>
          </DialogHeader>

          {/* Style Controls */}
          {themePresets.length > 0 && (
            <div className="bg-muted/30 p-2 rounded border mb-3 flex items-center gap-3">
              <span className="text-sm font-medium">ðŸŽ¨ Apply Brand Kit:</span>
              <select 
                className="text-sm border rounded p-1"
                onChange={(e) => {
                  const sel = themePresets.find(p => p.id === e.target.value);
                  if (sel) {
                      setFontName(sel.fontFamily);
                      setPrimaryColor(sel.primaryColor);
                      setOutlineColor(sel.outlineColor);
                      setAlignment(sel.alignment);
                      setMarginV(sel.marginV);
                  }
                }}
              >
                <option value="">-- Select Preset --</option>
                {themePresets.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
              </select>
            </div>
          )}
          <div className="grid grid-cols-2 md:grid-cols-5 gap-3 py-2 border-b">
            {[
              { label: "Font", value: fontName, setter: setFontName, options: [["Arial","Arial"],["Impact","Impact"],["Roboto","Roboto"],["Comic Sans MS","Comic Sans"]] },
              { label: "Karaoke Color", value: primaryColor, setter: setPrimaryColor, options: [["&H0000FFFF","Yellow"],["&H0000FF00","Green"],["&H00FF0000","Blue"],["&H00FFFFFF","White"]] },
              { label: "Outline", value: outlineColor, setter: setOutlineColor, options: [["&H00000000","Black"],["&H000000FF","Red"],["&H00FFFFFF","White"],["&H00808080","Gray"]] },
              { label: "Alignment", value: alignment, setter: setAlignment, options: [["2","Bottom"],["8","Top"],["5","Middle"]] },
            ].map(({ label, value, setter, options }) => (
              <div key={label}>
                <label className="text-xs font-semibold">{label}</label>
                <select className="w-full text-sm border rounded p-1 mt-1" value={value} onChange={e => setter(e.target.value)}>
                  {options.map(([val, name]) => <option key={val} value={val}>{name}</option>)}
                </select>
              </div>
            ))}
            <div>
              <label className="text-xs font-semibold">Margin Y</label>
              <Input type="number" className="h-8 mt-1" value={marginV} onChange={e => setMarginV(e.target.value)} />
            </div>
          </div>

          {/* Timing Editor */}
          <div className="grid gap-2 py-4 max-h-[50vh] overflow-y-auto">
            {editedChunks.map((chunk, idx) => (
              <div key={idx} className="flex flex-col gap-1 text-sm border-b pb-2">
                <div className="flex items-center gap-2">
                  <span className="w-6 font-semibold text-muted-foreground">{idx + 1}.</span>
                  <div className="flex items-center gap-1">
                    <Input type="number" className="w-20 h-7 text-xs" value={chunk.startMs} onChange={e => updateChunk(idx, 'startMs', parseInt(e.target.value) || 0)} />
                    <span className="text-muted-foreground text-xs">â€“</span>
                    <Input type="number" className="w-20 h-7 text-xs" value={chunk.endMs} onChange={e => updateChunk(idx, 'endMs', parseInt(e.target.value) || 0)} />
                  </div>
                </div>
                <Input className="w-full h-8 ml-8 text-sm" value={chunk.text} onChange={e => updateChunk(idx, 'text', e.target.value)} />
              </div>
            ))}
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setEditingClipIndex(null)}>Cancel</Button>
            <Button onClick={saveSubtitles}>Save Changes</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      {/* Schedule Post Dialog */}
      <Dialog open={scheduleModalOpen} onOpenChange={setScheduleModalOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Mulai Penjadwalan Postingan</DialogTitle>
            <DialogDescription>
              Klip akan diunggah ke platform terpilih secara background pada waktu yang ditentukan.
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-3 py-2">
            <div>
              <label className="text-xs font-semibold">Platform Tujuan</label>
              <select className="w-full h-9 border rounded px-2 mt-1 text-sm bg-background" value={postPlatform} onChange={e => setPostPlatform(e.target.value)}>
                <option value="youtube">YouTube Shorts</option>
                <option value="tiktok">TikTok</option>
                <option value="facebook">Facebook Reels</option>
              </select>
            </div>
            <div>
              <label className="text-xs font-semibold">Judul Video (Mendukung Hastag)</label>
              <Input className="mt-1" value={postTitle} onChange={e => setPostTitle(e.target.value)} />
            </div>
            <div>
              <label className="text-xs font-semibold">Deskripsi</label>
              <Input className="mt-1" value={postDesc} onChange={e => setPostDesc(e.target.value)} />
            </div>
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="text-xs font-semibold">Tanggal (YYYY-MM-DD)</label>
                <Input className="mt-1" type="date" value={postDate} onChange={e => setPostDate(e.target.value)} />
              </div>
              <div>
                <label className="text-xs font-semibold">Waktu / Jam</label>
                <Input className="mt-1" type="time" value={postTime} onChange={e => setPostTime(e.target.value)} />
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setScheduleModalOpen(false)}>Batal</Button>
            <Button onClick={handlePostSubmit}>Schedule Now</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

export default function ProjectDetailsPage() {
  return (
    <Suspense fallback={<div className="p-10 flex justify-center"><Loader2 className="animate-spin text-muted-foreground mr-2 h-5 w-5" />Loading Project...</div>}>
      <ProjectDetailsContent />
    </Suspense>
  );
}
